## 分治法

在计算机科学中，分治法是一种很重要的算法。分治法即『分而治之』，把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个思想是很多高效算法的基础，如排序算法（快速排序，归并排序）等。

## 分治法思想：递归与分而治之法

- 分：分成较小的可以递归解决的问题
- 治：从子问题的解形成原始问题的解
- 分而治之算法通常都是高效的递归算法
- 在分而治之法中，递归是“分”，额外的开销是“治”

分治法所能解决的问题一般具有以下几个特征：

1. 问题的规模缩小到一定的程度就可以容易地解决。
2. 问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。
3. 利用该问题分解出的子问题的解可以合并为该问题的解。
4. 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。

分治法的三个步骤是：

1. 分解（Divide）：将原问题分解为若干子问题，这些子问题都是原问题规模较小的实例。
2. 解决（Conquer）：递归地求解各子问题。如果子问题规模足够小，则直接求解。
3. 合并（Combine）：将所有子问题的解合并为原问题的解。

分治法的经典题目：

1. 二分搜索
2. 大整数乘法
3. Strassen矩阵乘法
4. 棋盘覆盖
5. 归并排序
6. 快速排序
7. 循环赛日程表
8. 汉诺塔

## 最大连续子序列问题

给定(可能是负的)整数序列A1 , A2 , ... An，寻找(并标识) $\sum_{k=i}^{j}A_k$ 的值为最大的序列。如果所有的整数都是负的，那么最大连续子序列的和是零。

例如，假设输入是{-2, 11, -4, 13, -5, 2}，那么答案是20，它表示连续子序列包含了第2项到第4项（如粗体字部分）。又如第二个例子，对于输入{1, -3, 4, -2, -1, 6},答案是7，这个子序列包含最后四项。

分而治之法的解题思路：

假设输入是{4，－3，5，－2，－1，2，6，－2}。我们把这个输入划分成两部分，前四个和后四个。这样最大连续子序列的和可能出现在下面三种情况中。

- 情况1：整个位于前半部，可递归计算。
- 情况2：整个位于后半部，可递归计算。
- 情况3：从前半部开始但在后半部结束。

情况3的解决方法：

从两半部分的边界开始，通过从右到左的扫描来找到左半段的最长序列。类似地，从左到右的扫描找到右半段的最长序列。把这两个子序列组合起来，形成跨越分割边界的最大连续子序列。

在这个实例中，结果序列是从第一部分的第一个元素到第二部分的其余元素。总和是两个子序列的和，即4+7=11。

算法总结：

- 递归地计算整个位于前半部的最大连续子序列。
- 递归地计算整个位于后半部的最大连续子序列。
- 通过两个连续循环，计算从前半部开始但在后半部结束的最大连续子序列的和。
- 选择三个和中的最大值。

```c
// 找出数组a的下标从left到right之间的和值最大的子序列
// 用法：maxsum(a, 0, n-1);
int maxSum(int a[ ], int left, int right )
{	// maxLeft和maxRight分别为左、右半部的最长子序列和
    int maxLeft, maxRight, center;   
    int leftSum = 0, rightSum = 0;
    int maxLeftTmp = NEGMAX, maxRightTmp = NEGMAX; // NEGMAX最大负整数            
   
    if (left == right) return a[left] > 0 ? a[left] : 0;
    center = (left + right) / 2;  
   
    maxLeft = maxSum(a, left, center);       // 找前半部分的最大连续子序列
    maxRight = maxSum(a, center + 1, right); // 找后半部分的最大连续子序列

    //找从前半部分开始到后半部分结束的最大连续子序列
    for (int i = center; i >= left; --i){
        leftSum += a[i];
        if (leftSum > maxLeftTmp)  maxLeftTmp = leftSum;
    }
    for (i = center + 1; i <= right; ++i){
        rightSum += a[i];
        if (rightSum > maxRightTmp)  maxRightTmp = rightSum;
    }
 
    return  max3(maxLeft, maxRight, maxLeftTmp + maxRightTmp);
}
```