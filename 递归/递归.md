## 递归的概念

递归（recursion）在数学及程序设计中是一种很重要的工具。递归的定义是：若一个对象部分地包含它自己，或用它自己给自己定义，则这个对象是递归的；若一个过程直接地或间接地调用自己，则称这个过程是递归的过程。

在以下两种情况下，常常用到递归的方法。

### 定义是递归的

许多对象的定义是递归的，像阶乘函数，斐波那契数列等。例如，阶乘的定义是：

![](images/阶乘.png)

又例如，链表结点的定义，也是递归的。链表结点node的定义由数据域data和指针域next组成，，而指针next则由node定义。

再例如，单链表的递归定义可以写为：

- 单个结点，其指针域next的值为NULL，是一个单链表；
- 一个结点，其指针域next指向一个单链表，整个仍是一个单链表。

### 问题的解法是递归的

汉诺塔问题是递归求解的一个典型问题，汉诺塔问题是：设有3根标号为A、B、C的针，在A 针上穿有n个盘子，一个比一个小。要求把A针上的盘子全部移到C针上。移动的规则是：

（1）一次只能移动一个盘子；

（2）移动过程中大盘子不能放在小盘子上面；

（3）在移动过程中盘子可以放在A、B、C的任意一根针上。

问题的解法为

如果n = 1，则将这一个盘子直接从A针移到C针上。否则执行以下三步：

（1） 用C针做过渡，将A针上的（n-1）个盘子移到B针上；
（2） 将A针上最后一个盘子直接移到C针上；
（3） 用A针做过渡，将B针上的(n-1)个盘子移到C针上。

移动过程如图4-9所示，图中n = 4。

![](images/汉诺塔.png)

移动n个盘子的汉诺塔问题归结为移动（n-1）个盘子的汉诺塔问题。与此类似，移动（n-1）个盘子的汉诺塔问题又可归结为移动（n-2）个盘子的汉诺塔问题，……，最后总可以归结到只移动一个盘子的汉诺塔问题。

求解汉诺塔问题的算法

```c++
# include <iostream.h>
void Hanoi (int n, char A, char B, char C)  {
	//把n 个盘子从A针借助B针移到C针上
	if (n == 1 ){ //递归出口，一个盘子直接移动
      	cout<<"Move"<<A<<"to"<<C<<endl;
	}else{
      	Hanoi (n-1 , A , C , B);       //将上面n-1个盘子移到B针上
      	cout<<"Move"<<A<<"to"<<C<<endl;//最后一个移到C针上
      	Hanoi (n-1, B,A,C);     //将B针上的n-1个盘子移到C针上
	}
}
```

### 递归过程与递归工作栈

我们知道，对一个非递归函数的调用，在函数调用前要保存以下三方面的信息：

- 返回地址
- 本函数调用时，与形参结合的实参值，包括函数名和函数参数。
- 本函数的局部变量值。

当函数调用返回时，要释放当初保存的实参值和局部变量值，然后按保存的返回地址返回。

对于一个递归函数的调用也是如此，在函数调用前也要保存上述三方面的信息。但因为递归函数的自调用特性，上述所保存的信息将由于函数不断地调用自身而互相重叠，如没有合适的存储结构来保存，这些信息就无法使用。在高级语言的处理程序中，使用了一个“递归工作栈”来进行处理。每一层递归调用所需保存的信息构成一个工作记录，每一个工作记录包括与前述类似的三方面的信息：

- 返回地址，即上一层中本次调用自身的语句的后继语句处
- 本次函数调用时，与形参结合的实参值，包括函数名、引用参数和值参数等
- 本层的局部变量值

在每进入一层递归时，系统就要建立一个新的工作记录，把上述项目登入，加到递归工作栈的栈顶。每退出一层递归，就从递归工作栈退出一个工作记录，栈顶的工作记录必定是当前正在执行的这一层的工作记录，也称其为“活动记录”。

下面以计算阶乘的递归函数为例，对于n为3时，分析递归函数的执行过程，以及递归函数调用时递归工作栈的变化过程。根据阶乘的定义

![](images/阶乘.png)

阶乘递归函数设计如下

```c++
long fact (int n) {
	if (n == 0){
      	return 1; //递归出口
	}else if{
      	return  n * fact(n-1); //递归调用
	}
}
```

计算3的阶乘时，递归函数调用的执行过程如图4-10所示。图中的x是自变量，y是x的阶乘，都是中间变量。图中箭头旁的数值代表函数的返回值y，最终fact(3) = 6。

当递归调用返回时，返回到上一层递归调用的下一语句，而这个返回位置正好是算法的结束处。这样，每次递归调用时保存的返回地址就不使用了。

n=3的阶乘递归函数调用的系统栈区的动态变化过程如图所示，图中符号 “*”表示值尚未知。 

![](images/递归阶乘.png)

![](images/递归阶乘2.png)

## 消除递归

根据前面的介绍可知，递归算法是一种分而治之的方法，它把复杂问题分解为简单问题来求解。对于某些复杂问题，用递归算法来分析比较有效，用递归算法来描述也比较自然、易理解。但递归算法的时间效率通常比较差。因此，在求解某些问题时，人们希望用递归算法来分析问题，用非递归算法来求解问题；另外，有些计算机语言不支持递归功能，这就需要把递归算法转化为非递归算法。

把递归算法转化为非递归算法通常采用如下两种方法：

- 对于尾递归和单向递归的算法，可用循环结构的算法来替代。
- 自己用栈来模拟系统运行时的栈，保存有关的信息，从而用非递归算法来模拟递归算法

### 尾递归和单向递归的消除

尾递归是指在递归算法的函数中，递归调用语句只有一个，而且是处在函数的最后，如前述的求解阶乘的函数。由于当递归调用返回时，是返回到上一层递归调用的下一语句，而这个返回位置正好是算法的结束处。因此，每次递归调用时保存的返回地址就不使用了，事实上，函数返回值和函数的参数也是不使用的。由此可知，对于尾递归形式的算法，不必利用系统的运行时的栈来保存各种信息。尾递归形式的算法可以很方便地用循环结构的形式来替代。

阶乘的求解可以写成如下循环结构的非递归算法：

```c++
long fact(int n){
      int product=1;
      for (int i=1; i<=n; i++)
        product= producti
      return product
}
```

单向递归是指递归函数中虽然有递归调用语句，但各递归调用语句的参数只和主调用函数有关，相互之间参数无关，并且这些递归调用语句都处在算法的最后。显然，尾递归是单向递归的特例。单向递归的一个典型例子就是斐波那契数列的递归算法。

斐波那契数列的递归定义是：

![](images/斐波那契.png)

计算此数列的递归函数如下：

```c++
long Fib(int n)
{ if (n == 0 || n ==1 ) return  n;     //递归出口
  else   return Fib(n-1)+Fib(n-2);     //递归调用
}
```

上述递归函数求Fib(4)过程可以用如图所示的递归调用树来描述。

为了计算Fib(4)，必须先计算Fib(3)；为了计算Fib(3)，必须先计算Fib(2)，…。求解的顺序在图上由数字①②③…表示。 

![](images/斐波那契递归.png)

在Fib(4)的求解过程中，Fib(4)、Fib(3)、Fib(2)、Fib(1)、Fib(0)的计算次数分别是1、1、2、3、2，累计递归调用次数是9。

实际上Fib(n)的递归调用次数NumberOfCall(n)与Fib(n)有关，它们之间的关系是：NumberOfCall(n)=2*Fib(n+1)-1。

例如：NumberOfCall(4)=2\*Fib(5)-1=2\*5-1=9，NumberOfCall(5)=2\*Fib(6)-1=2\*8-1=15

上述计算斐波那契数列的递归函数Fib(n)的时间复杂度为O(2ⁿ)。所以，用递归方法重复地调用函数和多次地传递参数，运行效率是很低的。实际上求解斐波那契数列Fib(n)的过程是一种单向递归的过程：为计算Fib(n)，先要计算Fib(n－1)和Fib(n－2)；为计算Fib(n－1)，又要计算Fib(n－2)和Fib(n－3)；…。

可直接考虑用简单的循环来计算斐波那契数列的第n项Fib(n)。算法的时间复杂度为O(n)。比递归算法的时间效率要高得多。

算法如下：

```c++
long Fib (int n) //用循环计算Fib(n)
{
	if (n == 0 || n == 1) return  n;      //Fib(0) 或Fib(1)的情况
	long twoback =0, oneback =1, current; //n>=2的情况
	for (int i = 2; i<= n; i++)
	{
      	current = twoback+oneback;
		twoback = oneback;
	 	oneback = current;
	}
	return current;
}
```

### 用栈模拟系统运行时的栈

如果要把一个非单句递归算法转换成非递归算法，就必须使用一个栈来模拟系统在运行递归算法时的栈，从而消除递归。现以汉诺塔问题为例来介绍这种方法。

在上述例子中给出的求解汉诺塔问题的递归算法中有两处递归调用语句，再加上主调用函数，所以在非递归模拟算法中应有三个模仿的返回地址。这三个返回地址分别返回主调用函数、第一次递归调用处和第二次递归调用处，用L1、L2和L3来分别对应这三个返回地址。另外，还使用了一个取值为1，2，3的变量模仿返回地址。在非递归模拟算法中每次需要保存四个参数和一个模仿返回地址，用来模拟系统运行时的栈是一个顺序栈。

```c++
struct Datatypes
{
  short int retAddr;         //模仿返回地址
  int nDisk;                 //参数n
  char SourcePeg;            //参数A
  char AuxPeg;               //参数B
  char DestPeg;              //参数C
};                           //定义顺序堆栈类的Datatype
```

```c++
#include ” SeqStack.h ” // 包括顺序堆栈类

void SimuTowers( int n, char A, char B, char C )
{
    Datatype    currArea; // 当前工作区
    SeqStack    s; // 模拟系统运行时的堆栈
    char        temp;
    short int   i;
// 当前工作区初始化
    currArea.retAddr    = 1;
    currArea.nDisk      = n;
    currArea.SourcePeg  = A;
    currArea.AuxPeg     = B;
    currArea.DestPeg    = C;
    s.Push( currArea ); // 当前工作区入栈
// 以下为模拟出口
start:
    if ( currArea.nDisk == 1 )
    {
        cout<< ” Move Disk 1 from Peg ” << currArea.SourcePeg
            << ” to Peg ” << currArea.DestPeg << endl;
        i = currarea.retAddr;
        currArea = s.Pop(); // 出栈恢复当前工作区
        switch ( i )
        {
        case 1: goto  L1;
        case 2: goto  L2;
case3: goto L3;
        }
    }
    // 以下模拟递归自调用过程
    s.Push( currArea ); // 当前工作区入栈
    currArea.nDisk--;
    temp = currArea.AuxPeg;
    currArea.AuxPeg     = currArea.DestPeg;
    currArea.DestPeg;   = temp;
    currArea.retAddr    = 2;
    goto start;
// 以下模拟返回第一次递归调用
L2:
    cout<< “ Move Disk ” << currArea.nDisk << “ from Peg ”
        << currArea.SourcePeg << ” to Peg ”
        << currArea.DestPeg << endl;
    s.Push( currArea );  // 当前工作区入栈
    currArea.nDisk--;
    temp = currArea.SourcePeg;
    currArea.SourcePeg  = currArea.AuxPeg;
    currArea.AuxPeg     = temp;
    currArea.retAddr    = 3;
    goto start;
// 以下模拟返回第二次递归调用
L3:
    i = currArea.retAddr;
    currArea = s.Pop();  // 出栈恢复当前工作区
    switch ( i )
    {
    case 1: goto L1;
    case 2: goto L2;
    case 3: goto L3 :
    }
    // 以下模拟返回主函数
    L1 :
    return;
}
```