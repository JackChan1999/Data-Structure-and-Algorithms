## 线性表的顺序存储实现
### seqlist.h

```c
#ifndef  __MY_SEQLIST_H__ 
#define __MY_SEQLIST_H__

typedef void SeqList;
typedef void SeqListNode;

SeqList* SeqList_Create(int capacity);

void SeqList_Destroy(SeqList* list);

void SeqList_Clear(SeqList* list);

int SeqList_Length(SeqList* list);

int SeqList_Capacity(SeqList* list);

int SeqList_Insert(SeqList* list, SeqListNode* node, int pos);

SeqListNode* SeqList_Get(SeqList* list, int pos);

SeqListNode* SeqList_Delete(SeqList* list, int pos);

#endif  //__MY_SEQLIST_H__
```

### seqlist.c

```c
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "seqlist.h"

//在结构体中套1级指针
typedef struct _tag_SeqList
{
	int length;
	int capacity;
	unsigned int *node;   //int* node[]
}TSeqList;

SeqList* SeqList_Create(int capacity)
{
	int ret = 0;
	TSeqList *tmp = NULL;

	tmp = (TSeqList *)malloc(sizeof(TSeqList));
	if (tmp == NULL)
	{
		ret = -1;
		printf("func SeqList_Create() err:%d \n", ret);
		return NULL;
	}
	memset(tmp, 0, sizeof(TSeqList));

	//根据capacity 的大小分配节点的空间
	tmp->node = (unsigned int *)malloc(sizeof(unsigned int *) * capacity);
	if (tmp->node  == NULL)
	{
		ret = -2;
		printf("func SeqList_Create() err: malloc err %d \n", ret);
		return NULL;
	}
	tmp->capacity = capacity;
	tmp->length = 0;
	return tmp;
}

void SeqList_Destroy(SeqList* list)
{
	TSeqList *tlist = NULL;
	if (list == NULL)
	{
		return ;
	}
	tlist = (TSeqList *)list;
	if (tlist->node != NULL)
	{
		free(tlist->node);
	}
	
	free(tlist);
	return ;
}

//清空链表，回到初始化状态
void SeqList_Clear(SeqList* list)
{
	TSeqList *tlist = NULL;
	if (list == NULL)
	{
		return ;
	}
	tlist = (TSeqList *)list;
	tlist->length = 0; 
	return ;
}

int SeqList_Length(SeqList* list)
{
	TSeqList *tlist = NULL;
	if (list == NULL)
	{
		return -1;
	}
	tlist = (TSeqList *)list;
	return tlist->length;
}

int SeqList_Capacity(SeqList* list)
{
	TSeqList *tlist = NULL;
	if (list == NULL)
	{
		return -1;
	}
	tlist = (TSeqList *)list;
	return tlist->capacity;
}

int SeqList_Insert(SeqList* list, SeqListNode* node, int pos)
{
	int i =0, ret = 0;
	TSeqList *tlist = NULL;

	if (list == NULL || node==NULL ||  pos<0)
	{
		ret = -1;
		printf("fun SeqList_Insert() err:%d \n", ret);
		return ret;
	}
	tlist = (TSeqList*)list;

	//判断是不是满了
	if (tlist->length >= tlist->capacity)
	{
		ret = -2;
		printf("fun SeqList_Insert() (tlist->length >= tlist->capacity) err:%d \n", ret);
		return ret;
	}

	//容错修正  6个长度 容量20;用户pos10位置插入
	if (pos>=tlist->length)
	{
		pos = tlist->length;
	}

	//1 元素后移
	for(i=tlist->length; i>pos; i--)
	{
		tlist->node[i] = tlist->node[i-1];
		//a[7] = a[6]
	}
	// i = 3
	// 2插入元素
	tlist->node[i] = (unsigned int)node;
	tlist->length ++;
	return 0;
}

SeqListNode* SeqList_Get(SeqList* list, int pos)
{
	int i =0;
	SeqListNode *ret = 0;
	TSeqList *tlist = NULL;

	if (list == NULL ||  pos<0)
	{
		printf("fun SeqList_Get() err:%d \n", ret);
		return NULL;
	}
	tlist = (TSeqList*)list;

	ret = (void *)tlist->node[pos];
	return ret;
}

SeqListNode* SeqList_Delete(SeqList* list, int pos)
{
	int i = 0;
	SeqListNode *ret = 0;
	TSeqList *tlist = NULL;

	if (list == NULL ||  pos<0) //检查
	{
		printf("fun SeqList_Delete() err:%d \n", ret);
		return NULL;
	}
	tlist = (TSeqList*)list;

	ret = (SeqListNode *)tlist->node[pos]; //缓存pos的位置
	 
	for (i=pos+1; i<tlist->length; i++)  //pos位置后面的元素前移
	{
		tlist->node[i-1] = tlist->node[i];
	}
	tlist->length --;
	return ret;
}
```

### 线性表顺序存储结构的测试

```c
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "seqlist.h"

typedef struct _Teacher
{
	int age;
	char name[64];
}Teacher;

typedef struct _Teacher2
{
	int age;
	char name[64];
}Teacher2;

typedef struct _Teacher3
{
	int age;
	char name[64];
	int age3;
}Teacher3;

void main()
{
	int		ret = 0, i = 0;
	SeqList* list = NULL;

	Teacher t1, t2, t3, t4,t5;
	t1.age = 31;
	t2.age = 32;
	t3.age = 33;
	t4.age = 34;
	t5.age = 35;

	list = SeqList_Create(10);
	if (list == NULL)
	{
		printf("func SeqList_Create() ret :%d \n", ret);
		return ;
	}

	ret = SeqList_Insert(list, (SeqListNode*) &t1, 0); //头插法
	ret = SeqList_Insert(list, (SeqListNode*) &t2, 0); //头插法
	ret = SeqList_Insert(list, (SeqListNode*) &t3, 0); //头插法
	ret = SeqList_Insert(list, (SeqListNode*) &t4, 0); //头插法
	ret = SeqList_Insert(list, (SeqListNode*) &t5, 0); //头插法

	//遍历
	for (i=0; i<SeqList_Length(list); i++)
	{
		Teacher*  tmp = (Teacher *) SeqList_Get(list, i);
		if (tmp == NULL)
		{
			return ;
		}
		printf("tmp->age:%d ", tmp->age);
	}

	//删除链表中的节点
	while( SeqList_Length(list) > 0 )
	{
		SeqList_Delete(list, 0);
	}

	system("pause");

	/*
	typedef void SeqList;
	typedef void SeqListNode;

	SeqList* SeqList_Create(int capacity);

	void SeqList_Destroy(SeqList* list);

	void SeqList_Clear(SeqList* list);

	int SeqList_Length(SeqList* list);

	int SeqList_Capacity(SeqList* list);

	int SeqList_Insert(SeqList* list, SeqListNode* node, int pos);

	SeqListNode* SeqList_Get(SeqList* list, int pos);

	SeqListNode* SeqList_Delete(SeqList* list, int pos);
	*/

	return ;
}
```
## 线性表的链式实现

### 单链表

#### 类模板LinkList.h

```C++
#pragma once

template<typename T>
struct Node
{
	T t;
	Node<T> *next;
};

template<typename T>
class LinkList
{
public:
	LinkList(void);
	~LinkList(void);
	//api

	//清空获取的长度
	int getLen();

	//向链表的某一个位置插入数据
	int insert(T &t, int pos);

	//从链表的某一个位置获取数据
	int get(int pos, T &t);

	//从链表的某一个位置删除数据
	int del(int pos, T &t);

private:
	int len;
	Node<T> *header;
};
```

#### 类模板LinkList.cpp

```C++
#include "LinkList.h"

template<typename T>
LinkList<T>::LinkList(void)
{
	header = new Node<T>;
	header->next = NULL;
	this->len = 0;
}

template<typename T>
LinkList<T>::~LinkList(void)
{
	Node<T> *tmp = NULL;
	
	while (header != NULL)
	{
      	//删除头节点之前 把下一个结点的位置给缓存下来，因为链表是单向的
		tmp = header->next; 
		delete header;
		header = tmp;
	}
	len = 0;
	header = NULL; //避免指针
}

//清空获取的长度
template<typename T>
int LinkList<T>::getLen()
{
	return len;
}

//向链表的某一个位置插入数据
template<typename T>
int  LinkList<T>::insert(T &t, int pos)
{
	//底层函数还没有结点的定义
	Node<T> *current = NULL;
	current = header;

	for (int i=0; i<pos; i++)
	{
		current = current->next;
	}
	//打造node 缓存用户的t
	Node<T> *node = new Node<T>;
	node->t = t; //缓存用户的数据  //注意 在这个地方 使用了=号操作 
	node->next = NULL;
	
	node->next = current->next;
	current->next = node;
	len ++;
	return 0;
}

//从链表的某一个位置获取数据
template<typename T>
int  LinkList<T>::get(int pos, T &t)
{
	//底层函数还没有结点的定义
	Node<T> *current = NULL;
	current = header;

	for (int i=0; i<pos; i++)
	{
		current = current->next;
	}
	
	t = current->next->t; //把缓存的t =号给引用t

	return 0;
}


//从链表的某一个位置删除数据
template<typename T>
int  LinkList<T>::del(int pos, T &t)
{
	Node<T> *current = NULL;
	Node<T> *ret = NULL;
	current = header;

	for (int i=0; i<pos; i++)
	{
		current = current->next;
	}
	ret = current->next;
	t = ret->t; //把要删除的结点传出去

	//指向删除操作
	current->next = ret->next;
	len -- ;
	//bug
	delete ret;

	return 0;
}
```

#### 链表模板类集成测试.cpp

```C++

#include <iostream>
using namespace std;
#include "LinkList.cpp"  //抛砖。。。

//1 出现深拷贝和浅copy的问题
//2 操作符重载 = 
//  copy构造函数

struct Teacher
{
	int age;
	char name[64];
};

void main01()
{
	Teacher t1, t2, t3;
	//t1.p = (char *)malloc(100);
	Teacher tmp;
	t1.age = 31;
	t2.age = 32;
	t3.age = 33;

	LinkList<Teacher> list;
	//插入结点
	list.insert(t1, 0 ); //头插法
	list.insert(t2, 0 ); //头插法
	list.insert(t3, 0 ); //头插法

	//遍历链表
	for (int i=0; i<3; i++)
	{
		list.get(i, tmp);
		cout<<tmp.age<<" ";
	}

	//删除链表

	while (list.getLen() > 0)
	{
		list.del(0, tmp);
		cout<<tmp.age<<" ";

	}
	
	
	return ;
}
void main02()
{
	Teacher t1, t2, t3;
	Teacher *tmp, *p1, *p2, *p3;
	t1.age = 31;
	t2.age = 32;
	t3.age = 33;
	p1 = &t1;
	p2 = &t2;
	p3 = &t3;

	LinkList<Teacher *> list;
	//插入结点
	list.insert(p1, 0 ); //头插法
	list.insert(p2, 0 ); //头插法
	list.insert(p3, 0 ); //头插法

	//遍历链表
	for (int i=0; i<3; i++)
	{
		list.get(i, tmp);
		cout<<tmp->age<<" ";
	}

	//删除链表

	while (list.getLen() > 0)
	{
		list.del(0, tmp);
		cout<<tmp->age<<" ";

	}


	return ;
}

void main()
{
	//main01();
	main02();
	cout<<"hello..."<<endl;
	system("pause");

}
```

#### LinkList.h

```c
#ifndef _MYLINKLIST_H_
#define _MYLINKLIST_H_

typedef void LinkList;
/*
typedef struct _tag_LinkListNode LinkListNode;
struct _tag_LinkListNode
{
	LinkListNode* next;
};
*/

typedef struct _tag_LinkListNode
{
	struct _tag_LinkListNode* next;
}LinkListNode;

//创建链表
LinkList* LinkList_Create();

//销毁链表
void LinkList_Destroy(LinkList* list);

//清空链表 
void LinkList_Clear(LinkList* list);

//清空获取的长度
int LinkList_Length(LinkList* list);

//向链表的某一个位置插入数据
int LinkList_Insert(LinkList* list, LinkListNode* node, int pos);

//从链表的某一个位置获取数据
LinkListNode* LinkList_Get(LinkList* list, int pos);

//从链表的某一个位置删除数据
LinkListNode* LinkList_Delete(LinkList* list, int pos);

#endif
```

#### LinkList.c

```c
#define  _CRT_SECURE_NO_WARNINGS 
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "LinkList.h"

// Linux内核链表，非传统链表
typedef struct _tag_LinkList
{
	LinkListNode header; // 第一个域（第一个元素）
	int length;
}TLinkList;
// 创建链表
LinkList* LinkList_Create()
{
	TLinkList *ret = (TLinkList *)malloc(sizeof(TLinkList));
	if (ret == NULL)
	{
		return NULL;
	}
	memset(ret, 0, sizeof(TLinkList) );
	ret->header.next = NULL;
	ret->length = 0;
	return ret;
}

// 销毁链表
void LinkList_Destroy(LinkList* list)
{
	if (list != NULL)
	{
		free(list);
	}
	return ;
}

//清空链表 
void LinkList_Clear(LinkList* list)
{
	TLinkList *tlist = (LinkList *)list;
	if (tlist == NULL)
	{
		return ;
	}
	tlist->header.next = NULL;
	tlist->length = 0;
	return ;
}

//清空获取的长度
int LinkList_Length(LinkList* list)
{
	TLinkList *tlist = (LinkList *)list;
	if (tlist == NULL)
	{
		return -1;
	}
	return tlist->length;
}


// 向链表的某一个位置插入数据
int LinkList_Insert(LinkList* list, LinkListNode* node, int pos)
{
	int ret = 0, i = 0;
	LinkListNode *current = NULL;
	TLinkList *tlist = NULL;

	tlist = (LinkList *)list;
	if (list==NULL || node==NULL || pos<0)
	{
		return -1;
	}
	current = &(tlist->header);

	for (i=0; i<pos; i++)
	{
		current = current->next;
	}
	//让node连接后续结点
	node->next = current->next;
	//让2号位置 连接 node
	current->next = node;
	tlist->length ++;

	return 0;
}

//从链表的某一个位置获取数据
LinkListNode* LinkList_Get(LinkList* list, int pos)
{
	int ret = 0, i = 0;
	LinkListNode *current = NULL;
	TLinkList *tlist = NULL;

	tlist = (LinkList *)list;
	if (list==NULL || pos<0)
	{
		return NULL;
	}
	current = &(tlist->header);

	for (i=0; i<pos; i++)
	{
		current = current->next;
	}
	return current->next;
}

//从链表的某一个位置删除数据
LinkListNode* LinkList_Delete(LinkList* list, int pos)
{
	//分析赋值指针变量
	int  i = 0;
	LinkListNode *current = NULL;
	LinkListNode *ret = NULL;

	TLinkList *tlist = NULL;

	tlist = (LinkList *)list;
	if (list==NULL || pos<0)
	{
		return NULL;
	}
	current = &(tlist->header);

	for (i=0; i<pos; i++)
	{
		current = current->next;
	}

	//假设删除位置3 
	ret = current->next;
	current->next = ret->next;
	tlist->length --;
	
	return ret;
}
```

#### 企业级链表的设计与实现集成测试.c

```c
#define  _CRT_SECURE_NO_WARNINGS 
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "LinkList.h"

typedef struct _Teacher
{
	LinkListNode node;
	int age;
	char name[64];
	int title;
}Teacher;

void main()
{
	int	ret = 0, i = 0;
	LinkList *list = NULL;
	Teacher t1, t2, t3, t4, t5;
	t1.age = 31;
	t2.age = 32;
	t3.age = 33;
	t4.age = 34;
	t5.age = 35;

	list = LinkList_Create();
	if (list ==NULL)
	{
		return ;
	}

	//向链表中插入结点
	//请问如何把老师的业务节点插入到链表中
	//好像：链表业务逻辑不支持老师业务节点的插入
	//效果 实现具体业务数据和链表算法的分离的
	ret = LinkList_Insert(list, (LinkListNode*) &t1, LinkList_Length(list)); //尾插法
	ret = LinkList_Insert(list, (LinkListNode*) &t2, LinkList_Length(list)); //尾插法
	ret = LinkList_Insert(list, (LinkListNode*) &t3, LinkList_Length(list)); //尾插法
	ret = LinkList_Insert(list, (LinkListNode*) &t4, LinkList_Length(list)); //尾插法
	ret = LinkList_Insert(list, (LinkListNode*) &t5, LinkList_Length(list)); //尾插法

	//遍历链表
	for (i=0; i<LinkList_Length(list); i++)
	{
		Teacher *tmp = (Teacher *)LinkList_Get(list, i);
		if (tmp == NULL)
		{
			return ;
		}
		printf("age:%d ", tmp->age);
	}

	//链表结点删除
	while (LinkList_Length(list) > 0)
	{
		Teacher *tmp = (Teacher *)LinkList_Delete(list, 0);
		if (tmp == NULL)
		{
			return ;
		}
		printf("age:%d ", tmp->age);
	}

	LinkList_Destroy(list);

	system("pause");
	return ;
}
```
### 循环链表

#### circlelist.h

```c
#ifndef _CIRCLELIST_H_
#define _CIRCLELIST_H_

typedef void CircleList;
/*
typedef struct _tag_CircleListNode CircleListNode;
struct _tag_CircleListNode
{
	CircleListNode* next;
};
*/
typedef struct _tag_CircleListNode
{
	struct _tag_CircleListNode * next;
}CircleListNode;

CircleList* CircleList_Create();

void List_Destroy(CircleList* list);

void CircleList_Clear(CircleList* list);

int CircleList_Length(CircleList* list);

int CircleList_Insert(CircleList* list, CircleListNode* node, int pos);

CircleListNode* CircleList_Get(CircleList* list, int pos);

CircleListNode* CircleList_Delete(CircleList* list, int pos);

//add

CircleListNode* CircleList_DeleteNode(CircleList* list, CircleListNode* node);

CircleListNode* CircleList_Reset(CircleList* list);

CircleListNode* CircleList_Current(CircleList* list);

CircleListNode* CircleList_Next(CircleList* list);

#endif
```

#### circlelist.c

```c
#include <stdio.h>
#include <malloc.h>
#include "CircleList.h"

typedef struct _tag_CircleList
{
	CircleListNode header;
	CircleListNode* slider; // 游标
	int length;
} TCircleList;

CircleList* CircleList_Create() // O(1)
{
	TCircleList* ret = (TCircleList*)malloc(sizeof(TCircleList));
	if (ret == NULL)
	{
		return NULL;
	}
	
	ret->length = 0;
	ret->header.next = NULL;
	ret->slider = NULL;
	return ret;
}

void CircleList_Destroy(CircleList* list) // O(1)
{
	if (list == NULL)
	{
		return ;
	}
	free(list);
}

void CircleList_Clear(CircleList* list) // O(1)
{
	TCircleList* sList = (TCircleList*)list;
	if (sList == NULL)
	{
		return ;
	}
	sList->length = 0;
	sList->header.next = NULL;
	sList->slider = NULL;
}

int CircleList_Length(CircleList* list) // O(1)
{
	TCircleList* sList = (TCircleList*)list;
	int ret = -1;
	if (list == NULL)
	{
		return ret;
	}
	ret = sList->length;
	return ret;
}

int CircleList_Insert(CircleList* list, CircleListNode* node, int pos) // O(n)
{ 
	int ret = 0, i=0;
	TCircleList* sList = (TCircleList*)list;

	if (list == NULL || node== NULL || pos<0)
	{
		return -1;
	}
	//if( ret )
	{
		CircleListNode* current = (CircleListNode*)sList;

		for(i=0; (i<pos) && (current->next != NULL); i++)
		{
			current = current->next;
		}

		//current->next 0号节点的地址
		node->next = current->next; //1
		current->next = node; //2

		//若第一次插入节点
		if( sList->length == 0 )
		{
			sList->slider = node;
		}

		sList->length++;

		//若头插法 current仍然指向头部
		//（原因是：跳0步，没有跳走）
		if( current == (CircleListNode*)sList )
		{
			//获取最后一个元素
			CircleListNode* last = CircleList_Get(sList, sList->length - 1); 
			last->next = current->next; //3
		}
	}

	return ret;
}

CircleListNode* CircleList_Get(CircleList* list, int pos) // O(n)
{
	TCircleList* sList = (TCircleList*)list;
	CircleListNode* ret = NULL;
	int i = 0;

	if (list==NULL || pos<0)
	{
		return NULL;
	}
	//if( (sList != NULL) && (pos >= 0) && (sList->length > 0) )
	{
		CircleListNode* current = (CircleListNode*)sList;

		for(i=0; i<pos; i++)
		{
			current = current->next;
		}

		ret = current->next;
	}

	return ret;
}

CircleListNode* CircleList_Delete(CircleList* list, int pos) // O(n)
{
	TCircleList* sList = (TCircleList*)list;
	CircleListNode* ret = NULL;
	int i = 0;

	if( (sList != NULL) && (pos >= 0) && (sList->length > 0) )
	{
      	// CircleListNode* current = (CircleListNode*)(&(sList->header));
		CircleListNode* current = (CircleListNode*)sList;
		CircleListNode* last = NULL;

		for(i=0; i<pos; i++)
		{
			current = current->next;
		}

		//若删除第一个元素（头结点）
		if( current == (CircleListNode*)sList )
		{
			last = (CircleListNode*)CircleList_Get(sList, sList->length - 1);
		}

		//求要删除的元素
		ret = current->next;
		current->next = ret->next;

		sList->length--;

		//判断链表是否为空
		if( last != NULL )
		{
			sList->header.next = ret->next;
			last->next = ret->next;
		}

		//若删除的元素为游标所指的元素
		if( sList->slider == ret )
		{
			sList->slider = ret->next;
		}

		//若删除元素后，链表长度为0
		if( sList->length == 0 )
		{
			sList->header.next = NULL;
			sList->slider = NULL;
		}
	}

	return ret;
}

CircleListNode* CircleList_DeleteNode(CircleList* list, CircleListNode* node) // O(n)
{
	TCircleList* sList = (TCircleList*)list;
	CircleListNode* ret = NULL;
	int i = 0;

	if( sList != NULL )
	{
		CircleListNode* current = (CircleListNode*)sList;
		
		//查找node在循环链表中的位置i
		for(i=0; i<sList->length; i++)
		{
			if( current->next == node )
			{
				ret = current->next;
				break;
			}

			current = current->next;
		}
		
		//如果ret找到，根据i去删除	
		if( ret != NULL )
		{
			CircleList_Delete(sList, i);
		}
	}

	return ret;
}

CircleListNode* CircleList_Reset(CircleList* list) // O(1)
{
	TCircleList* sList = (TCircleList*)list;
	CircleListNode* ret = NULL;

	if( sList != NULL )
	{
		sList->slider = sList->header.next;
		ret = sList->slider;
	}

	return ret;
}

CircleListNode* CircleList_Current(CircleList* list) // O(1)
{
	TCircleList* sList = (TCircleList*)list;
	CircleListNode* ret = NULL;

	if( sList != NULL )
	{
		ret = sList->slider;
	}

	return ret;
}

//把当前位置返回，并且游标下移
CircleListNode* CircleList_Next(CircleList* list) // O(1)
{
	TCircleList* sList = (TCircleList*)list;
	CircleListNode* ret = NULL;

	if( (sList != NULL) && (sList->slider != NULL) )
	{
		ret = sList->slider;
		sList->slider = ret->next;
	}

	return ret;
}
```

#### maincirclelist01_基本功能测试01.c

```c
#include <stdio.h>
#include <stdlib.h>
#include "CircleList.h"


struct Value
{
	CircleListNode circlenode;
	int v;
};

int main21(int argc, char *argv[])
{
	CircleList* list = CircleList_Create();

	struct Value v1;
	struct Value v2;
	struct Value v3;
	struct Value v4;
	struct Value v5;
	struct Value v6;
	struct Value v7;
	struct Value v8;

	int i = 0;

	v1.v = 1;
	v2.v = 2;
	v3.v = 3;
	v4.v = 4;
	v5.v = 5;
	v6.v = 6;
	v7.v = 7;
	v8.v = 8;

	CircleList_Insert(list, (CircleListNode*)&v1, 0);
	CircleList_Insert(list, (CircleListNode*)&v2, 0);
	CircleList_Insert(list, (CircleListNode*)&v3, 0);
	CircleList_Insert(list, (CircleListNode*)&v4, 0);

	for(i=0; i<2*CircleList_Length(list); i++) //怎么样证明是循环链表
	{
		struct Value* pv = (struct Value*)CircleList_Get(list, i);

		printf("%d\n", pv->v);
	}

	while( CircleList_Length(list) > 0 )
	{
		CircleList_Delete(list, 0);
	}

	printf("\n");

	CircleList_Destroy(list);

	system("pause");

	return 0;
}
```

#### maincirclelist02_约瑟夫问题求解.c

约瑟夫问题-循环链表典型应用：n 个人围成一个圆圈，首先第 1 个人从 1 开始一个人一个人顺时针报数，报到第 m 个人，令其出列。然后再从下一 个人开始从 1 顺时针报数，报到第 m 个人，再令其出列，…，如此下去，求出列顺序。

```c
#include <stdio.h>
#include <stdlib.h>
#include "CircleList.h"

struct Value
{
	CircleListNode header;
	int v;
};

void  main()
{
	int i = 0;
	CircleList* list = CircleList_Create();

	struct Value v1, v2, v3, v4, v5, v6, v7, v8;

	v1.v = 1;	v2.v = 2;	v3.v = 3;	v4.v = 4;	
	v5.v = 5;	v6.v = 6;	v7.v = 7;	v8.v = 8;

	CircleList_Insert(list, (CircleListNode*)&v1, CircleList_Length(list));
	CircleList_Insert(list, (CircleListNode*)&v2, CircleList_Length(list));
	CircleList_Insert(list, (CircleListNode*)&v3, CircleList_Length(list));
	CircleList_Insert(list, (CircleListNode*)&v4, CircleList_Length(list));
	CircleList_Insert(list, (CircleListNode*)&v5, CircleList_Length(list));
	CircleList_Insert(list, (CircleListNode*)&v6, CircleList_Length(list));
	CircleList_Insert(list, (CircleListNode*)&v7, CircleList_Length(list));
	CircleList_Insert(list, (CircleListNode*)&v8, CircleList_Length(list));
	

	for(i=0; i<CircleList_Length(list); i++)
	{
		//获取游标所指元素,然后游标下移
		struct Value* pv = (struct Value*)CircleList_Next(list);
		printf("%d\n", pv->v);
	}

	printf("\n");


	//重置游标
	CircleList_Reset(list);

	while( CircleList_Length(list) > 0 )
	{
		struct Value* pv = NULL;
		for(i=1; i<3; i++)
		{
			CircleList_Next(list);
		}
		pv = (struct Value*)CircleList_Current(list);
		printf("%d\n", pv->v);
		CircleList_DeleteNode(list, (CircleListNode*)pv);
	}

	CircleList_Destroy(list);

	system("pause");
	return ;
}
```

#### maincirclelist03_基本功能测试.c

```c
#include <stdio.h>
#include <stdlib.h>
#include "CircleList.h"


struct Value
{
	CircleListNode header;
	int v;
};

void  main()
{
	int i = 0;
	CircleList* list = CircleList_Create();

	struct Value v1;
	struct Value v2;
	struct Value v3;
	struct Value v4;
	struct Value v5;
	struct Value v6;
	struct Value v7;
	struct Value v8;

	v1.v = 1;
	v2.v = 2;
	v3.v = 3;
	v4.v = 4;
	v5.v = 5;
	v6.v = 6;
	v7.v = 7;
	v8.v = 8;

	CircleList_Insert(list, (CircleListNode*)&v1, CircleList_Length(list));
	CircleList_Insert(list, (CircleListNode*)&v2, CircleList_Length(list));
	CircleList_Insert(list, (CircleListNode*)&v3, CircleList_Length(list));
	CircleList_Insert(list, (CircleListNode*)&v4, CircleList_Length(list));

	//CircleList_Insert(list, (CircleListNode*)&v5, 5);
	//CircleList_Delete(list, 0);

	for(i=0; i<2*CircleList_Length(list); i++)
	{
		struct Value* pv = (struct Value*)CircleList_Get(list, i);
		printf("%d\n", pv->v);
	}

	printf("\n");

	while( CircleList_Length(list) > 0 )
	{
		struct Value* pv = (struct Value*)CircleList_Delete(list, 0);

		printf("%d\n", pv->v);
	}

	printf("\n");
// 
// 	CircleList_Insert(list, (CircleListNode*)&v1, CircleList_Length(list));
// 	CircleList_Insert(list, (CircleListNode*)&v2, CircleList_Length(list));
// 	CircleList_Insert(list, (CircleListNode*)&v3, CircleList_Length(list));
// 	CircleList_Insert(list, (CircleListNode*)&v4, CircleList_Length(list));
// 	CircleList_Insert(list, (CircleListNode*)&v5, CircleList_Length(list));
// 	CircleList_Insert(list, (CircleListNode*)&v6, CircleList_Length(list));
// 	CircleList_Insert(list, (CircleListNode*)&v7, CircleList_Length(list));
// 	CircleList_Insert(list, (CircleListNode*)&v8, CircleList_Length(list));
// 
// 	for(i=0; i<CircleList_Length(list); i++)
// 	{
// 		struct Value* pv = (struct Value*)CircleList_Next(list);
// 
// 		printf("%d\n", pv->v);
// 	}

	printf("\n");

	//重置游标
	CircleList_Reset(list);

	while( CircleList_Length(list) > 0 )
	{
		struct Value* pv = NULL;

		for(i=1; i<3; i++)
		{
			CircleList_Next(list);
		}

		pv = (struct Value*)CircleList_Current(list);

		printf("%d\n", pv->v);

		CircleList_DeleteNode(list, (CircleListNode*)pv);
	}

	CircleList_Destroy(list);

	system("pause");
	return ;
}
```

### 双向链表

#### dlinklist.h

为什么需要双向链表？

- 单链表的结点都只有一个指向下一个结点的指针
- 单链表的数据元素无法直接访问其前驱元素
- 逆序访问单链表中的元素是极其耗时的操作！

```c
#ifndef _MY_DLINKLIST_H_
#define _MY_DLINKLIST_H_

typedef void DLinkList;
/*
typedef struct _tag_DLinkListNode DLinkListNode;
struct _tag_DLinkListNode
{
	DLinkListNode* next;
	DLinkListNode* pre;
};
*/

typedef struct _tag_DLinkListNode
{
	struct _tag_DLinkListNode* next;
	struct _tag_DLinkListNode * pre;
}DLinkListNode;

DLinkList* DLinkList_Create();

void DLinkList_Destroy(DLinkList* list);

void DLinkList_Clear(DLinkList* list);

int DLinkList_Length(DLinkList* list);

int DLinkList_Insert(DLinkList* list, DLinkListNode* node, int pos);

DLinkListNode* DLinkList_Get(DLinkList* list, int pos);

DLinkListNode* DLinkList_Delete(DLinkList* list, int pos);

//-- add
DLinkListNode* DLinkList_DeleteNode(DLinkList* list, DLinkListNode* node);

DLinkListNode* DLinkList_Reset(DLinkList* list);

DLinkListNode* DLinkList_Current(DLinkList* list);

DLinkListNode* DLinkList_Next(DLinkList* list);

DLinkListNode* DLinkList_Pre(DLinkList* list);

#endif
```

#### dlinklist.c

```c
#include <stdio.h>
#include <malloc.h>
#include "DLinkList.h"

typedef struct _tag_DLinkList
{
	DLinkListNode header;
	DLinkListNode* slider;
	int length;
} TDLinkList;

DLinkList* DLinkList_Create() 
{
	TDLinkList* ret = (TDLinkList*)malloc(sizeof(TDLinkList));

	if( ret != NULL )
	{
		ret->length = 0;
		ret->header.next = NULL;
		ret->header.pre = NULL;
		ret->slider = NULL;
	}

	return ret;
}

void DLinkList_Destroy(DLinkList* list) 
{
	if (list != NULL)
	{
		free(list);
	}
}

void DLinkList_Clear(DLinkList* list) 
{
	TDLinkList* sList = (TDLinkList*)list;

	if( sList != NULL )
	{
		sList->length = 0;
		sList->header.next = NULL;
		sList->header.pre = NULL;
		sList->slider = NULL;
	}
}

int DLinkList_Length(DLinkList* list) 
{
	TDLinkList* sList = (TDLinkList*)list;
	int ret = -1;

	if( sList != NULL )
	{
		ret = sList->length;
	}

	return ret;
}

//大家一定要注意：教科书不会告诉你 项目上如何用；哪些点是项目的重点
int DLinkList_Insert(DLinkList* list, DLinkListNode* node, int pos) 
{ 
	int ret = 0, i = 0;
	TDLinkList* sList = (TDLinkList*)list;
	
	if (list==NULL || node==NULL || pos<0)
	{
		return -1;
	}
	
	{
		DLinkListNode* current = (DLinkListNode*)sList;
		DLinkListNode* next = NULL; //需要增加next指针

		for(i=0; (i<pos) && (current->next != NULL); i++)
		{
			current = current->next;
		}

		next = current->next;

		//步骤1-2
		current->next = node;
		node->next = next;

		//步骤3-4 
		if( next != NULL ) //当链表插入第一个元素，需要特殊处理
		{
			next->pre = node;
		}
		node->pre = current;

		if( sList->length == 0 )
		{
			sList->slider = node; //当链表插入第一个元素处理游标
		}

		//若在0位置插入，需要特殊处理 新来结点next前pre指向null
		if( current == (DLinkListNode*)sList )
		{
			node->pre = NULL;
		}

		sList->length++;
	}

	return ret;
}

DLinkListNode* DLinkList_Get(DLinkList* list, int pos) 
{
	TDLinkList* sList = (TDLinkList*)list;
	DLinkListNode* ret = NULL;
	int i = 0;

	if( (sList != NULL) && (0 <= pos) && (pos < sList->length) )
	{
		DLinkListNode* current = (DLinkListNode*)sList;

		for(i=0; i<pos; i++)
		{
			current = current->next;
		}

		ret = current->next;
	}

	return ret;
}

//插入第一个节点
//删除的是最后一个结点，该是如何处理
DLinkListNode* DLinkList_Delete(DLinkList* list, int pos) 
{
	TDLinkList* sList = (TDLinkList*)list;
	DLinkListNode* ret = NULL;
	int i = 0;
	if (sList == NULL || pos <0 )
	{
		return NULL;
	}
	//if( (sList != NULL) && (0 <= pos) && (pos < sList->length) )
	{
		DLinkListNode* current = (DLinkListNode*)sList;
		DLinkListNode* next = NULL; //需要增加next指针

		for(i=0; i<pos; i++)
		{
			current = current->next;
		}

		ret = current->next;
		next = ret->next;

		//步骤1
		current->next = next;

		//步骤2 
		if( next != NULL )//需要特殊处理
		{
			next->pre = current;

			if( current == (DLinkListNode*)sList ) //若第0个位置，需要特殊处理
			{
				next->pre = NULL;
			}
		}

		if( sList->slider == ret )
		{
			sList->slider = next;
		}

		sList->length--;
	}

	return ret;
}

DLinkListNode* DLinkList_DeleteNode(DLinkList* list, DLinkListNode* node)
{
	TDLinkList* sList = (TDLinkList*)list;
	DLinkListNode* ret = NULL;
	int i = 0;

	if( sList != NULL )
	{
		DLinkListNode* current = (DLinkListNode*)sList;

		for(i=0; i<sList->length; i++)
		{
			if( current->next == node )
			{
				ret = current->next;
				break;
			}

			current = current->next;
		}

		if( ret != NULL )
		{
			DLinkList_Delete(sList, i);
		}
	}

	return ret;
}

DLinkListNode* DLinkList_Reset(DLinkList* list)
{
	TDLinkList* sList = (TDLinkList*)list;
	DLinkListNode* ret = NULL;

	if( sList != NULL )
	{
		sList->slider = sList->header.next;
		ret = sList->slider;
	}

	return ret;
}

DLinkListNode* DLinkList_Current(DLinkList* list)
{
	TDLinkList* sList = (TDLinkList*)list;
	DLinkListNode* ret = NULL;

	if( sList != NULL )
	{
		ret = sList->slider;
	}

	return ret;
}

DLinkListNode* DLinkList_Next(DLinkList* list)
{
	TDLinkList* sList = (TDLinkList*)list;
	DLinkListNode* ret = NULL;

	if( (sList != NULL) && (sList->slider != NULL) )
	{
		ret = sList->slider;
		sList->slider = ret->next;
	}

	return ret;
}

DLinkListNode* DLinkList_Pre(DLinkList* list)
{
	TDLinkList* sList = (TDLinkList*)list;
	DLinkListNode* ret = NULL;

	if( (sList != NULL) && (sList->slider != NULL) )
	{
		ret = sList->slider;
		sList->slider = ret->pre;
	}

	return ret;
}
```

#### dlinklistmain01.c

```c
#include <stdio.h>
#include <stdlib.h>
#include "DLinkList.h"

struct Value
{
	DLinkListNode node;
	int v;
};

int main()
{
	int i = 0;
	DLinkList* list = DLinkList_Create();
	struct Value* pv = NULL;
	struct Value v1, v2, v3, v4, v5;

	v1.v = 1;	v2.v = 2;	v3.v = 3;	v4.v = 4;
	v5.v = 5;

	DLinkList_Insert(list, (DLinkListNode*)&v1, DLinkList_Length(list));
	DLinkList_Insert(list, (DLinkListNode*)&v2, DLinkList_Length(list));
	DLinkList_Insert(list, (DLinkListNode*)&v3, DLinkList_Length(list));
	DLinkList_Insert(list, (DLinkListNode*)&v4, DLinkList_Length(list));
	DLinkList_Insert(list, (DLinkListNode*)&v5, DLinkList_Length(list));

	for(i=0; i<DLinkList_Length(list); i++)
	{
		pv = (struct Value*)DLinkList_Get(list, i);

		printf("%d\n", pv->v);
	}

	printf("\n");

	DLinkList_Delete(list, DLinkList_Length(list)-1);
	DLinkList_Delete(list, 0);
	//DLinkList_Delete(list, 3);
	

	for(i=0; i<DLinkList_Length(list); i++)
	{
		pv = (struct Value*)DLinkList_Next(list);

		printf("%d\n", pv->v);
	}

	printf("\n");

	DLinkList_Reset(list);
	DLinkList_Next(list);

	pv = (struct Value*)DLinkList_Current(list);

	printf("%d\n", pv->v);

	DLinkList_DeleteNode(list, (DLinkListNode*)pv);

	pv = (struct Value*)DLinkList_Current(list);

	printf("%d\n", pv->v);

	DLinkList_Pre(list);

	pv = (struct Value*)DLinkList_Current(list);

	printf("%d\n", pv->v);

	printf("Length: %d\n", DLinkList_Length(list));

	DLinkList_Destroy(list);
	system("pause");
	return 0;
}
```

优点：

- 双向链表在单链表的基础上增加了指向前驱的指针
- 功能上双向链表可以完全取代单链表的使用
- 双向链表的Next，Pre和Current操作可以高效的遍历链表中的所有元素

缺点：代码复杂