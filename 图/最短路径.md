## 最短路径

利用带权的图也可以表示n个城市之间的交通运输网络。此时图中的每一个顶点用于表示一个城市，图中的每一条边用于表示两个城市之间的直接交通运输路线，每条边上所附的权值可以表示该路线的长度或沿此路线运输所花费的时间或运费等。

从图中某一顶点(称为源点)到达另一顶点(称为终点)的路径可能不止一条（也就是说两个城市之间的通路可能有多条），但人们往往比较关心的是如何找到从一个城市到另一个城市花费最少的一条路径，也就是说要寻找带权有向图中两个顶点之间路径长度最短的路径。

这个问题就是所谓的最短路径问题。本节将讨论最常见的三种求解最短路径的方法。

## 弧上权值为非负情形的单源点最短路径问题 

所谓弧上权值为非负情形的单源点最短路径问题就是对于给定一个带权有向图G（G中所有弧上的权均为非负值）与源点v，求从v到G中其余各顶点的最短路径。

如下图所示的带权有向图。设源点为A，则源点A到其余顶点的最短路径分别为：（A、B）路径长度为10，（A、D、C）路径长度为50，（A、D）路径长度为30，（A、D、C、E）路径长度为60。

![](img/最短路径.png)

迪杰斯特拉(Dijkstra)提出了按路径长度的递增次序，逐条产生最短路径的方法。首先求出从源点v0到其余各顶点中长度最短的一条，然后参照它求出长度次短的一条最短路径，依次类推，直到从源点v0到其余各顶点的最短路径全部求出为止。

具体做法是：设集合S存放已经求出的最短路径的终点，初始状态时，集合S中只有一个源点v0（S={v0}）。以后每求得一条最短路径(v0，…，vk)，就将vk加入到集合S中，直到全部顶点都加入到集合S中，算法就可以结束了。

如图给出了按照迪杰斯特拉算法对前图所示带权有向图逐步求最短路径的过程。

![](img/最短路径2.png)

在迪杰斯特拉算法中，为了记录当前找到的从源点v0到其余各顶点的最短路径长度，需引入一个辅助数组dist[]。它的每一个分量dist[i]表示当前找到的从源点v0到终点vi的相对最短路径的长度。它的初始状态是：若从源点v0到顶点vi有弧，则dist[i]为该弧上的权值；否则dist[i]为∞。

同时，为了记录从源点v0到其余各顶点的最短路径，还需引入一个辅助数组path[]。它的每一个分量path[i]表示从源点v0到顶点vi的最短路径上的顶点vi的直接前驱顶点。

设第一条最短路径为(v0，vi)，则有：dist[i]＝Min{dist[j] | vj ∈ V-S}

那么下一条最短路径是哪一条呢？假设下一条最短路径的终点是vk，则可想而知，它或者是(v0，vk)，或者是(v0，vi，vk)。其长度或者是弧<v0，vk>上的权值，或者是dist[i]与弧<vi，vk>上的权值之和。

一般情况下，假设S是已求得的最短路径的终点的集合，vx(vx ∈ V-S)为下一条最短路径的终点，则可证明：这条最短路径必然是从v0出发，或者直接到达顶点vx，或者中间只经过S中的顶点便可到达顶点vx的路径中的一条。对此可以用反证法加以证明。 

如图是前图所示的带权有向图为例，利用迪杰斯特拉算法，逐次选取从源点v0到其余各顶点的最短路径的过程中辅助数组dist、path和S的变化。

![](img/迪杰斯特拉算法.png)

为了利用迪杰斯特拉算法计算最短路径，需要在图的邻接矩阵存储结构的类定义中增加用于表示辅助数组的成员数据。

```c++
class Graph {  //图的类定义  
private:
    float * dist; //最短路径长度数组
    int *path;	 //最短路径数组
    int *s; //最短路径顶点集	
public:
    void ShortestPath ( int n, int v);
    int choose ( int );
}
```

迪杰斯特拉算法的实现：

```c++
void Graph :: ShortestPath ( int n, int v ){
    float min ; 
    int u ;
    dist = new float[n]; s = new int[n]; path = new int[n];
    for ( int i = 0; i < n; i++) {
        dist[i] = Arcs[v][i]; //dist数组初始化
        s[i] = 0;  
        if ( i != v && dist[i] < MAXNUM) path[i] = v;
          else path[i] = -1;        //path数组初始化    } 
    	S[v] = 1; //顶点v加入顶点集合s
		for ( i = 0; i < n-1; i++ )
        min = MAXNUM;  u = v;
        for ( int j = 0; j < n; j++ )
        if ( !s[j] && dist[j] < min ) 
           { u = j;  min = dist[j]; }
        s[u] = 1;                //将顶点u加入集合S
        for ( int w = 0; w < n; w++ )    //修改dist和path 
           if ( !s[w] && dist[u] + Arcs[u][w] < dist[w] ) {
              dist[w] = dist[u] + Arcs [u][w]; 
              path[w] = u;  }
  }
} 
```

## 弧上权值为任意值的单源点最短路径问题 

在上一节中讨论了弧上权值为非负值的情况，接下来讨论更一般的情况，假设带权有向图G上弧的权值可能为负值。

例如，对于如图所示的带权有向图来说，利用上节给出的迪克斯特拉算法，不一定能得到正确的结果。

![](img/最短路径3.png)

为了能够求解弧上带有负权值的单源最短路径问题，贝尔曼（BelLnam）和福特（Ford）提出了从源点逐次经过其它顶点，以缩短到达终点的最短路径长度的方法。该方法有一个限制条件，即要求图中不能有路径长度为负值的回路。

当图中没有路径长度为负值的回路时，有n个顶点的图中任意两个顶点之间如果存在最短路径，此路径最多有n-1条弧。 

在贝尔曼—福特算法中，构造一个最短路径长度的数组序列：$ dist^1[]、dist^2[]、…、dist^{n-1}[] $ 。

其中，$ dist^1[u] $ 表示从源点v0直接到终点u的最短路径的长度，即 $ dist^1[u]＝Arcs[v_0][u] $；

而dist2[u]表示从源点v0出发最多经过两条弧（一个中间顶点）到达终点u的最短路径的长度，…，

distk[u]是从源点v0出发最多经过不构成带负长度回路的k条弧（k-1个中间顶点）到达终点u的最短路径的长度。算法的结果就是计算出distn-1[u]。