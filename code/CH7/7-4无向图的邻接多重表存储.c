 #include<limits.h> /* INT_MAX等 */
 #include<stdio.h> /* EOF(=^Z或F6),NULL */
 #include<stdlib.h> /* atoi() */
 #include<io.h> /* eof() */
 #include<math.h> /* floor(),ceil(),abs() */
 #include<process.h> /* exit() */
 /* 函数结果状态代码 */
 #define TRUE 1
 #define FALSE 0
 #define OK 1
 #define ERROR 0
 #define INFEASIBLE -1
 /* #define OVERFLOW -2 因为在math.h中已定义OVERFLOW的值为3,故去掉此行 */
 typedef int Status; /* Status是函数的类型,其值是函数结果状态代码，如OK等 */
 typedef int Boolean; /* Boolean是布尔类型,其值是TRUE或FALSE */ 
 
 #define MAX_NAME 3 /* 顶点字符串的最大长度+1 */
 typedef int InfoType; /* 权值类型 */
 typedef char VertexType[MAX_NAME]; /* 字符串类型 */
 #define MAX_VERTEX_NUM 20
 typedef enum{unvisited, visited} VisitIf;
 typedef struct EBox
 {
   VisitIf mark; /* 访问标记 */
   int ivex, jvex; /* 该边依附的两个顶点的位置 */
   struct EBox *ilink, *jlink; /* 分别指向依附这两个顶点的下一条边 */
   InfoType *info; /* 该边信息指针，可指向权值或其他信息 */
 }EBox;
 typedef struct
 {
   VertexType data;
   EBox *firstedge; /* 指向第一条依附该顶点的边 */
 }VexBox;
 typedef struct
 {
   VexBox adjmulist[MAX_VERTEX_NUM];
   int vexnum, edgenum; /* 无向图的当前顶点数和边数 */
 }AMLGraph;
 
 Boolean visite[MAX_VERTEX_NUM]; /* 访问标志数组(全局量) */
 void(*VisitFunc)(VertexType v);
 typedef int QElemType; /* 队列元素类型 */
 typedef struct QNode
 {
 	QElemType data;
 	struct QNode *next;
 }QNode, * QueuePtr;
 typedef struct 
 {
 	QueuePtr front, rear;//队头，队尾指针 
 }LinkQueue;
 
int LocateVex(AMLGraph G, VertexType u);
void CreateGraph(AMLGraph *G);
VertexType* GetVex(AMLGraph G, int v);
Status PutVex(AMLGraph *G, VertexType v, VertexType value);
int FirstAdjVex(AMLGraph G, VertexType v);
int NextAdjVex(AMLGraph G, VertexType v, VertexType w);
Status InsertVex(AMLGraph *G, VertexType v);
Status DeleteArc(AMLGraph *G, VertexType v, VertexType w);
Status DeleteVex(AMLGraph *G, VertexType v);
void DestroyGraph(AMLGraph *G);
Status InsertArc(AMLGraph *G, VertexType v, VertexType w);
void DFS(AMLGraph G, int v);
void DFSTraverse(AMLGraph G, void(*visit)(VertexType));
void InitQueue(LinkQueue *Q);
void DestroyQueue(LinkQueue *Q);
void ClearQueue(LinkQueue *Q);
Status QueueEmpty(LinkQueue Q);
int QueueLength(LinkQueue Q);
Status GetHead_Q(LinkQueue Q, QElemType *e);//避免重名
void EnQueue(LinkQueue *Q, QElemType e);
Status DeQueue(LinkQueue *Q, QElemType *e);
void QueueTraverse(LinkQueue Q, void(*vi)(QElemType));
void BFSTraverse(AMLGraph G, void(*Visit)(VertexType));
void MarkUnvizited(AMLGraph G);
void Display(AMLGraph G);
void visit(VertexType v);

int main()
{
   int k,n;
   AMLGraph g;
   VertexType v1,v2;
   
   CreateGraph(&g);
   Display(g);
   printf("修改顶点的值，请输入原值 新值: ");
   scanf("%s%s",v1,v2);
   PutVex(&g,v1,v2);
   printf("插入新顶点，请输入顶点的值: ");
   scanf("%s",v1);
   InsertVex(&g,v1);
   printf("插入与新顶点有关的边，请输入边数: ");
   scanf("%d",&n);
   for(k=0;k<n;k++)
   {
     printf("请输入另一顶点的值: ");
     scanf("%s",v2);
     InsertArc(&g,v1,v2);
   }
   Display(g);
   printf("删除一条边，请输入待删除边的两顶点(以空格作为间隔)：");
   scanf("%s%s",v1,v2);
   DeleteArc(&g,v1,v2);
   Display(g);
   printf("删除顶点及相关的边，请输入顶点的值: ");
   scanf("%s",v1);
   DeleteVex(&g,v1);
   Display(g);
   printf("深度优先搜索的结果:\n");
   DFSTraverse(g,visit);
   printf("广度优先搜索的结果:\n");
   BFSTraverse(g,visit);
   DestroyGraph(&g);
	
	return 0;
}
 
 
 int LocateVex(AMLGraph G, VertexType u)
 { /* 初始条件：无向图G存在，u和G中顶点有相同特征 */
   /* 操作结果：若G中存在顶点u，则返回该顶点在无向图中位置；否则返回-1 */
   int i;
   
   for(i=0; i<G.vexnum; ++i)
   { 
     if(strcmp(u,G.adjmulist[i].data) == 0)
     { 
       return i;
     } 
   } 
   return -1;
 }

 void CreateGraph(AMLGraph *G)
 { 
   /* 采用邻接多重表存储结构，构造无向图G */
   int i, j, k, IncInfo;
   VertexType va, vb;
   EBox *p;
   
   printf("请输入无向图的顶点数,边数,是否为带权图(是:1，否:0): ");
   scanf("%d,%d,%d", &(*G).vexnum, &(*G).edgenum, &IncInfo);
   printf("请输入%d个顶点的值(<%d个字符):\n", (*G).vexnum, MAX_NAME);
   for(i=0; i<(*G).vexnum; ++i) /* 构造顶点向量 */
   {
     scanf("%s", (*G).adjmulist[i].data);
     (*G).adjmulist[i].firstedge = NULL;
   }
   
   printf("请顺序输入每条边的两个端点(以空格作为间隔):\n");
   
   for(k=0; k<(*G).edgenum; ++k) /* 构造表结点链表 */
   {
     scanf("%s%s%*c", va, vb); /* %*c吃掉回车符 */
     i = LocateVex(*G, va); /* 一端 */
     j = LocateVex(*G, vb); /* 另一端 */
     p = (EBox*)malloc(sizeof(EBox));
     p->mark = unvisited; /* 设初值 */
     p->ivex = i;
     p->ilink = (*G).adjmulist[i].firstedge; /* 插在表头 */
     (*G).adjmulist[i].firstedge = p;
     p->jvex = j;
     p->jlink = (*G).adjmulist[j].firstedge; /* 插在表头 */
     (*G).adjmulist[j].firstedge = p;
     if(IncInfo) /* 网 */
     {
       p->info = (InfoType*)malloc(sizeof(InfoType));
       printf("请输入该边的权值: ");
       scanf("%d", p->info);
     }
     else
     { 
       p->info = NULL;
     } 
   }
 }

 VertexType* GetVex(AMLGraph G, int v)
 { 
   /* 初始条件：无向图G存在，v是G中某个顶点的序号。操作结果：返回v的值 */
   if(v>=G.vexnum || v<0)
   { 
     exit(ERROR);
   } 
   return &G.adjmulist[v].data;
 }

 Status PutVex(AMLGraph *G, VertexType v, VertexType value)
 { 
   /* 初始条件：无向图G存在，v是G中某个顶点。操作结果：对v赋新值value */
   int i;
   
   i = LocateVex(*G, v);
   if(i < 0) /* v不是G的顶点 */
   { 
     return ERROR;
   } 
   strcpy((*G).adjmulist[i].data, value);
   
   return OK;
 }

 int FirstAdjVex(AMLGraph G, VertexType v)
 { 
   /* 初始条件：无向图G存在，v是G中某个顶点 */
   /* 操作结果：返回v的第一个邻接顶点的序号。若顶点在G中没有邻接顶点，则返回-1 */
   int i;
   i = LocateVex(G, v);
   if(i < 0) /* G中不存在顶点v */
   { 
     return -1;
   }
    
   if(G.adjmulist[i].firstedge) /* v有邻接顶点 */
   { 
     if(G.adjmulist[i].firstedge->ivex == i)
     { 
       return G.adjmulist[i].firstedge->jvex;
     } 
	 else
	 { 
       return G.adjmulist[i].firstedge->ivex;
     } 
   } 
   else
   { 
     return -1;
   } 
 }

 int NextAdjVex(AMLGraph G, VertexType v, VertexType w)
 { 
   /* 初始条件：无向图G存在，v是G中某个顶点，w是v的邻接顶点 */
   /* 操作结果：返回v的(相对于w的)下一个邻接顶点的序号。若w是v的最后一个邻接点，则返回-1 */
   int i, j;
   EBox *p;
   
   i = LocateVex(G, v); /* i是顶点v的序号 */
   j = LocateVex(G, w); /* j是顶点w的序号 */
   if(i<0 || j<0) /* v或w不是G的顶点 */
   { 
     return -1;
   } 
   p = G.adjmulist[i].firstedge; /* p指向顶点v的第1条边 */
   while( p )
   { 
     if(p->ivex==i && p->jvex!=j) /* 不是邻接顶点w(情况1) */
     { 
       p = p->ilink; /* 找下一个邻接顶点 */
     } 
	 else if(p->jvex==i && p->ivex!=j) /* 不是邻接顶点w(情况2) */
	 { 
       p = p->jlink; /* 找下一个邻接顶点 */
     } 
	 else /* 是邻接顶点w */
	 { 
       break;
     } 
   } 
   
   if(p && p->ivex==i && p->jvex==j) /* 找到邻接顶点w(情况1) */
   {
     p = p->ilink;
     if(p && p->ivex==i)
     { 
       return p->jvex;
     } 
	 else if(p && p->jvex==i)
	 { 
       return p->ivex;
     } 
   }
   if(p && p->ivex==j && p->jvex==i) /* 找到邻接顶点w(情况2) */
   {
     p = p->jlink;
     if(p && p->ivex==i)
     { 
       return p->jvex;
     } 
	 else if(p && p->jvex==i)
	 { 
       return p->ivex;
     } 
   }
   
   return -1;
 }

 Status InsertVex(AMLGraph *G, VertexType v)
 { 
   /* 初始条件：无向图G存在，v和G中顶点有相同特征 */
   /* 操作结果：在G中增添新顶点v(不增添与顶点相关的弧，留待InsertArc()去做) */
   if((*G).vexnum == MAX_VERTEX_NUM) /* 结点已满，不能插入 */
   { 
     return ERROR;
   } 
   if(LocateVex(*G,v) >= 0) /* 结点已存在，不能插入 */
   { 
     return ERROR;
   } 
   strcpy((*G).adjmulist[(*G).vexnum].data, v);
   (*G).adjmulist[(*G).vexnum++].firstedge = NULL;
   
   return OK;
 }

 Status DeleteArc(AMLGraph *G, VertexType v, VertexType w)
 { 
   /* 初始条件：无向图G存在，v和w是G中两个顶点。操作结果：在G中删除弧<v,w> */
   int i, j;
   EBox *p, *q;
   i = LocateVex(*G, v);
   j = LocateVex(*G, w);
   if(i<0 || j<0 || i==j)
   { 
     return ERROR;  /* 图中没有该点或弧。以下使指向待删除边的第1个指针绕过这条边 */
   } 
   p = (*G).adjmulist[i].firstedge; /* p指向顶点v的第1条边 */
   if(p && p->jvex==j) /* 第1条边即为待删除边(情况1) */
   { 
     (*G).adjmulist[i].firstedge = p->ilink;
   } 
   else if(p && p->ivex==j) /* 第1条边即为待删除边(情况2) */
   { 
     (*G).adjmulist[i].firstedge = p->jlink;
   } 
   else /* 第1条边不是待删除边 */
   {
     while(p) /* 向后查找弧<v,w> */
     { 
       if(p->ivex==i && p->jvex!=j) /* 不是待删除边 */
       {
         q = p;
         p = p->ilink; /* 找下一个邻接顶点 */
       }
       else if(p->jvex==i && p->ivex!=j) /* 不是待删除边 */
       {
         q = p;
         p = p->jlink; /* 找下一个邻接顶点 */
       }
       else /* 是邻接顶点w */
       { 
         break;
       } 
	 } //while
     if(! p) /* 没找到该边 */
     { 
       return ERROR;
     } 
	 if(p->ivex==i && p->jvex==j) /* 找到弧<v,w>(情况1) */
	 { 
       if(q->ivex == i)
       {
         q->ilink = p->ilink;
       }
	   else
	   {
   		
   	
         q->jlink = p->ilink;
	   }
	 } 
	 else if(p->ivex==j && p->jvex==i) /* 找到弧<v,w>(情况2) */
	 {
       if(q->ivex == i)
       {
         q->ilink = p->jlink;
       }
	   else
	   {
         q->jlink = p->jlink;
	   }
	 }//else if
   }//else
    /* 以下由另一顶点起找待删除边且删除之 */
   p = (*G).adjmulist[j].firstedge; /* p指向顶点w的第1条边 */
   if(p->jvex == i) /* 第1条边即为待删除边(情况1) */
   {
     (*G).adjmulist[j].firstedge = p->ilink;
   }
   else if(p->ivex == i) /* 第1条边即为待删除边(情况2) */
   {
     (*G).adjmulist[j].firstedge = p->jlink;
   }
   else /* 第1条边不是待删除边 */
   {
     while(p) /* 向后查找弧<v,w> */
     {
       if(p->ivex==j && p->jvex!=i) /* 不是待删除边 */
       {
         q = p;
         p = p->ilink; /* 找下一个邻接顶点 */
       }
       else if(p->jvex==j && p->ivex!=i) /* 不是待删除边 */
       {
         q = p;
         p = p->jlink; /* 找下一个邻接顶点 */
       }
       else /* 是邻接顶点v */
       {
         break;
       }
	 }//while
     if(p->ivex==i && p->jvex==j) /* 找到弧<v,w>(情况1) */
     {
       if(q->ivex == j)
       {
         q->ilink = p->jlink;
       }
	   else
	   {
         q->jlink = p->jlink;
	   }
	 }
	 else if(p->ivex==j && p->jvex==i) /* 找到弧<v,w>(情况2) */
	 {
       if(q->ivex == j)
       {
         q->ilink = p->ilink;
       }
	   else
	   {
         q->jlink = p->ilink;
	   }
	 }//else if
   }//else
   if( p->info ) /* 有相关信息(或权值) */
   {
     free(p->info); /* 释放相关信息(或权值) */
   }
   free(p); /* 释放结点 */
   (*G).edgenum--; /* 边数-1 */
   
   return OK;
 }

 Status DeleteVex(AMLGraph *G, VertexType v)
 { 
   /* 初始条件：无向图G存在，v是G中某个顶点。操作结果：删除G中顶点v及其相关的边 */
   int i, j;
   EBox *p;
   
   i = LocateVex(*G, v); /* i为待删除顶点的序号 */
   if(i < 0)
   {
     return ERROR;
   }
   for(j=0; j<(*G).vexnum; j++) /* 删除与顶点v相连的边(如果有的话) */
   {
     DeleteArc(G, v, (*G).adjmulist[j].data); /* 如果存在此弧，则删除 */
   }
   for(j=i+1; j<(*G).vexnum; j++) /* 排在顶点v后面的顶点的序号减1 */
   {
     (*G).adjmulist[j-1] = (*G).adjmulist[j];
   }
   (*G).vexnum--; /* 顶点数减1 */
   for(j=i; j<(*G).vexnum; j++) /* 修改序号大于i的顶点在表结点中的序号 */
   {
     p = (*G).adjmulist[j].firstedge;
     if(p)
     {
       if(p->ivex == j+1)
       {
         p->ivex--;
         p = p->ilink;
       }
       else
       {
         p->jvex--;
         p = p->jlink;
       }//else
     }//if
   }//for
   
   return OK;
 }

 void DestroyGraph(AMLGraph *G)
 { 
   /* 初始条件：有向图G存在。操作结果：销毁有向图G */
   int i;
   
   for(i=(*G).vexnum-1; i>=0; i--) /* 由大到小依次删除顶点 */
   {
     DeleteVex(G, (*G).adjmulist[i].data);
   }
 }

 Status InsertArc(AMLGraph *G, VertexType v, VertexType w)
 { 
   /* 初始条件：无向图G存在，v和W是G中两个顶点。操作结果：在G中增添弧<v,w> */
   int i, j, IncInfo;
   EBox *p;
   i = LocateVex(*G, v); /* 一端 */
   j = LocateVex(*G, w); /* 另一端 */
   if(i<0 || j<0 || i==j)
   {
     return ERROR;
   }
   p = (EBox*)malloc(sizeof(EBox));
   p->mark = unvisited;
   p->ivex = i;
   p->ilink = (*G).adjmulist[i].firstedge; /* 插在表头 */
   (*G).adjmulist[i].firstedge = p;
   p->jvex = j;
   p->jlink = (*G).adjmulist[j].firstedge; /* 插在表头 */
   (*G).adjmulist[j].firstedge = p;
   printf("该边是否有权值(1:有 0:无): ");
   scanf("%d", &IncInfo);
   if(IncInfo) /* 有权值 */
   {
     p->info = (InfoType*)malloc(sizeof(InfoType));
     printf("请输入该边的权值: ");
     scanf("%d", p->info);
   }
   else
   {
     p->info = NULL;
   }
   (*G).edgenum++;
   
   return OK;
 }

 void DFS(AMLGraph G, int v)
 {
   int j;
   EBox *p;
   
   VisitFunc(G.adjmulist[v].data);
   visite[v] = TRUE;
   p = G.adjmulist[v].firstedge;
   while( p )
   {
     j = p->ivex==v ? p->jvex : p->ivex;
     
     if(! visite[j])
     {
       DFS(G, j);
     }
	 p = p->ivex == v ? p->ilink : p->jlink;
   }
 }

 void DFSTraverse(AMLGraph G, void(*visit)(VertexType))
 { 
   /* 初始条件：图G存在，Visit是顶点的应用函数。算法7.4 */
   /* 操作结果：从第1个顶点起，深度优先遍历图G，并对每个顶点调用函数Visit一次且仅一次 */
   int v;
   
   VisitFunc = visit;
   for(v=0; v<G.vexnum; v++)
   {
     visite[v] = FALSE;
   }
   for(v=0; v<G.vexnum; v++)
   {
     if(! visite[v])
     {
       DFS(G, v);
     }
   }
   printf("\n");
 }


 
 void InitQueue(LinkQueue *Q)
 {
 	//构造一个空队列Q
	(*Q).front = (*Q).rear = (QueuePtr)malloc(sizeof(QNode));
	
	if (! (*Q).front)
	{
		exit(OVERFLOW);
	}  
	
	(*Q).front->next = NULL;
 } 
 
 void DestroyQueue(LinkQueue *Q)
 {
 	//销毁队列Q(无论空否均可)
	while ( (*Q).front )
	{
		(*Q).rear = (*Q).front->next;
		free( (*Q).front );
		(*Q).front = (*Q).rear;
	}//while 
 } 
 
 void ClearQueue(LinkQueue *Q)
 {
 	//将Q清为空队列
	QueuePtr p, q;
	
	(*Q).rear = (*Q).front;
	p = (*Q).front->next;
	(*Q).front->next = NULL;
	
	while (p)
	{
		q = p;
		p = p->next;
		free(q);
	} //while
 }
 
 Status QueueEmpty(LinkQueue Q)
 {
 	//若Q为空队列，则返回TRUE，否则返回FALSE
	 if (Q.front->next == NULL)
	 {
	 	return TRUE;
 	 }  
 	 else
 	 {
 	 	return FALSE;
 	 }
 }
 
 int QueueLength(LinkQueue Q)
 {
 	//求队列长度
	 int i = 0;
	 QueuePtr p;
	 
	 p = Q.front;
	 
	 while (Q.rear != p)
	 {
	 	i++;
	 	p = p->next;
     } 
     
     return i;
 }
 
 Status GetHead_Q(LinkQueue Q, QElemType *e)//避免重名
 {
 	//若队列不空，则用e返回Q的队头元素，并返回OK，否则返回ERROR
	QueuePtr p;
	
	if (Q.front == Q.rear)
	{
		return ERROR;
	}
	
	p = Q.front->next;
	*e = p->data;
	
	return OK;
 } 
 
 void EnQueue(LinkQueue *Q, QElemType e)
 {
 	//插入元素e为Q的新的队尾元素
	QueuePtr p = (QueuePtr)malloc(sizeof(QNode));
	if (! p)//存储分配失败
	{
		exit(OVERFLOW); 
	} 
	p->data = e;
	p->next = NULL;
	(*Q).rear->next = p;
	(*Q).rear = p;
 }
 
 Status DeQueue(LinkQueue *Q, QElemType *e)
 {
 	//队列不为空，删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR
	QueuePtr p;
	
	if ((*Q).front == (*Q).rear)
	{
		return ERROR;
	} 
	p = (*Q).front->next;
	*e = p->data;
	(*Q).front->next = p->next;
	if ((*Q).rear == p)
	{
		(*Q).rear == (*Q).front;
	}
	free(p);
	
	return OK;	
 }
 
 void QueueTraverse(LinkQueue Q, void(*vi)(QElemType))
 {
 	//从队头到队尾依次对队列Q中每个元素调用函数vi（）
	QueuePtr p;
	
	p = Q.front->next;
	
	while ( p )
	{
		vi(p->data);
		p = p->next;
	} 
	printf("\n");
 }
 
 void BFSTraverse(AMLGraph G, void(*Visit)(VertexType))
 { 
   /* 初始条件：图G存在，Visit是顶点的应用函数。算法7.6 */
   /* 操作结果：从第1个顶点起，按广度优先非递归遍历图G，并对每个顶点调用函数 */
   /*           Visit一次且仅一次。使用辅助队列Q和访问标志数组visite */
   int v, u, w;
   LinkQueue Q;
   
   for(v=0; v<G.vexnum; v++)
   {
     visite[v] = FALSE; /* 置初值 */
   }
   InitQueue(&Q); /* 置空的辅助队列Q */
   for(v=0; v<G.vexnum; v++)
   {
     if(! visite[v]) /* v尚未访问 */
     {
       visite[v] = TRUE; /* 设置访问标志为TRUE(已访问) */
       Visit(G.adjmulist[v].data);
       EnQueue(&Q, v); /* v入队列 */
       while(! QueueEmpty(Q)) /* 队列不空 */
       {
         DeQueue(&Q,&u); /* 队头元素出队并置为u */
         for(w=FirstAdjVex(G,G.adjmulist[u].data); w>=0; w=NextAdjVex(G,G.adjmulist[u].data,G.adjmulist[w].data))
         {
		   if(! visite[w]) /* w为u的尚未访问的邻接顶点的序号 */
           {
             visite[w] = TRUE;
             Visit(G.adjmulist[w].data);
             EnQueue(&Q, w);
           }
         }//for
       }//while
     }//if
   }//for
   
   printf("\n");
 }

 void MarkUnvizited(AMLGraph G)
 { 
   /* 置边的访问标记为未被访问 */
   int i;
   EBox *p;
   
   for(i=0; i<G.vexnum; i++)
   {
     p = G.adjmulist[i].firstedge;
     while( p )
     {
       p->mark = unvisited;
       if(p->ivex == i)
       {
         p = p->ilink;
       }
	   else
	   {
         p = p->jlink;
	   }
	 }//while
   }//for
   
 }

 void Display(AMLGraph G)
 { 
   /* 输出无向图的邻接多重表G */
   int i;
   EBox *p;
   
   MarkUnvizited(G); /* 置边的访问标记为未被访问 */
   printf("%d个顶点：\n",G.vexnum);
   
   for(i=0; i<G.vexnum; ++i)
   {
     printf("%s ", G.adjmulist[i].data);
   }
   printf("\n%d条边:\n",G.edgenum);
   for(i=0; i<G.vexnum; i++)
   {
     p = G.adjmulist[i].firstedge;
     while(p)
     {
       if(p->ivex == i) /* 边的i端与该顶点有关 */
       {
         if(! p->mark) /* 只输出一次 */
         {
           printf("%s－%s ", G.adjmulist[i].data, G.adjmulist[p->jvex].data);
           p->mark = visited;
           if( p->info) /* 输出附带信息 */
           {
             printf("权值: %d ", *p->info);
           }
		 }
		 
         p = p->ilink;
       }
       else /* 边的j端与该顶点有关 */
       {
         if(! p->mark) /* 只输出一次 */
         {
           printf("%s－%s ", G.adjmulist[p->ivex].data, G.adjmulist[i].data);
           p->mark = visited;
           if(p->info) /* 输出附带信息 */
           {
             printf("权值: %d ",*p->info);
           }
		 }//if
         p = p->jlink;
       }//else
     }//while
     printf("\n");
   }//for
 }
 
 void visit(VertexType v)
 {
   printf("%s ",v);
 }
 
 