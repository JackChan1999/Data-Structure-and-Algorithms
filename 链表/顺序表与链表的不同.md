### 存储结构方面

（1）顺序表

顺序表是在存储器中分配一段连续的存储空间，逻辑上相邻的数据元素其物理存储地址也是相邻的。顺序表一旦分配其大小就是固定的无法更改，表中存储的元素的个数与表的大小未必相同，如分配4个单元大小的顺序表，可能只存储了3个元素。如果顺序表存储已满就无法再往里存储元素。

在顺序存储中，只要确定了线性表在存储空间里的起始位置，线性表中任意元素就都可随机存取，所以线性表的顺序存储结构是一种随机存取的结构。

（2）链表

在链式存储中，结点之间的存储单元地址可能是不连续的。链式存储中每个结点都包含两个部分：存储元素本身的数据域和存储结点地址的指针域。结点中的指针指向的是下一个结点，直到最后一个结点没有后继结点而指向空。
在链表中，这些存储单元可以是不连续的，因此它可以提高空间利用率，当需要存储元素时，哪儿有空闲的空间就在哪儿分配，只要将分配的空间地址保存到上一个结点就可以。

### 基本操作方面

（1）顺序表

在顺序表中存取元素时，它可以根据给出的下标快速计算出元素的存储地址，从而达到随机读取的目的。

但是，如果在顺序存储中插入或删除元素，效率会特别低。对插入来说，只限于在表的长度小于表的容量的顺序表中，如果插入大量数据，很难保证空间是否充足。而且一旦分配了存储空间，如果想要扩充容量，需要重新分配空间，然后将原来的数据复制到新的空间中，非常麻烦。另一方面，即使空间充足，那么在插入位置之后的元素必须都要向后移动，这个效率非常低。同理，如果要删除大量元素，那么势必会造成空间的浪费，而且删除元素后，后面的元素都要向前移动，效率也会非常低。

（2）链表

链表没有索引标注，存储单元的空间并不连续，如果要查找某一个元素，必须先得经过它的上一个结点中的地址才能找到它，因此不管遍历哪一个元素，都必须把它前面的元素都遍历后才能找到它，效率就不如顺序表高。

当在链表中某一个位置插入元素时，从空闲空间中为该元素分配一个存储单元，然后将两个结点之间的指针断开，上一个结点的指针指向新分配的存储单元，新分配的结点中指针指向下一个结点；这样不需要移动原来元素的位置，效率比较高；同样，当删除链表中的某个元素时，就断开它与前后两个结点的指针，然后将它的前后两个结点连接起来，也不需要移动原来元素的位置。与顺序表相比较，在插入删除元素方面，链表的效率要比顺序表高许多。